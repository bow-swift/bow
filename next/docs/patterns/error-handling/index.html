<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Bow</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Bow is a library for Typed Functional Programming in Swift">
    <meta name="keywords" content="functional-programming, swift-library, monads, monad-transformers, functional-data-structure, swift, fp-types, adt, free-monads, tagless-final, mtl, for-comprehension, category-theory">

    <meta property="og:image" content="" />
    <meta property="og:title" content="Bow" />
    <meta property="og:site_name" content="Bow" />
    <meta property="og:url" content="https://bow-swift.io" />
    <meta property="og:type" content="website" />
    <meta property="og:description" content="Bow is a library for Typed Functional Programming in Swift" />
    <meta property="og:keywords" content="functional-programming, swift-library, monads, monad-transformers, functional-data-structure, swift, fp-types, adt, free-monads, tagless-final, mtl, for-comprehension, category-theory" />

    <meta name="twitter:text:description" content="Bow is a library for Typed Functional Programming in Swift" />
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:site" content="@bow_swift">
    <meta name="twitter:creator" content="@bow_swift">
    <meta name="twitter:image" content="https://bow-swift.io/img/twitter-card.png" />

    <!-- Bow version metadata -->
    
    <meta name="bow-version" data-title="next" />

    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>

    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.6.3/css/all.css" integrity="sha384-UHRtZLI+pbxtHCWp1t77Bi1L4ZtiqrqD80Kn4Z8NTSRyMA2Fd33n5dQ8lWUE00s/" crossorigin="anonymous">

    <!-- Favicon -->
    <link rel="shortcut icon" href="/next/img/favicon.png">
    <!-- Main css -->
    <link rel="stylesheet" type="text/css" href="/next/css/docs.css">
    <!-- Highlighting css -->
    <link rel="stylesheet" type="text/css" href="/next/api-docs/css/highlight.css">

    <!-- Code to manage version information -->
    <script src="/next/js/doc-versions.js" defer></script>

    
        <!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-18433785-19"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-18433785-19');
</script>

    

</head>

<body id="doc-body">
<div id="wrapper">
    <div id="sidebar-wrapper">
    <div class="sidebar-brand">
        <a class="brand" href="/next/">
            <img src="/next/img/icon.svg" alt="Bow logo">
            <span>Bow</span>
        </a>
        <button type="button" id="main-toggle" class="sidebar-toggle">
            <span class="close"></span>
        </button>
    </div>

    <div id="version-dropdown">

    <button class="button link-like" onclick="displayToggle(event)" title="Documentation">
      <span>Bow version</span>
      <span id="bow-version">
        
        next
      </span>
    </button>

    <ul class="dropdown dropdown-content">

      <li class="dropdown-item">
        <a class="dropdown-item-link" href="/docs">
            <span>
              0.7.0
            </span>
        </a>
      </li>

      
      <li class="dropdown-item">
        <a class="dropdown-item-link" href="/next/docs">
            <span>
              next
            </span>
        </a>
      </li>
      
    </ul>
</div>


    <ul class="sidebar-nav">
        
        <li class="sidebar-nav-item">
            <a href="#">
                <span>Quick start</span>
                
                <i class="fa fa-angle-right"></i>
                
            </a>
            
            <ul>
                
                <li>
                    <a href="/next/docs/quick-start/getting-started/">
                        <i class="fa fa-circle"></i>
                        <span>Getting started</span>
                    </a>
                </li>
                
                <li>
                    <a href="/next/docs/quick-start/modules/">
                        <i class="fa fa-circle"></i>
                        <span>Modules</span>
                    </a>
                </li>
                
                <li>
                    <a href="/next/docs/quick-start/resources/">
                        <i class="fa fa-circle"></i>
                        <span>Resources</span>
                    </a>
                </li>
                
            </ul>
            
        </li>
        
        <li class="sidebar-nav-item">
            <a href="#">
                <span>FP concepts</span>
                
                <i class="fa fa-angle-right"></i>
                
            </a>
            
            <ul>
                
                <li>
                    <a href="/next/docs/fp-concepts/glossary/">
                        <i class="fa fa-circle"></i>
                        <span>Glossary</span>
                    </a>
                </li>
                
                <li>
                    <a href="/next/docs/fp-concepts/functions-vs-procedures/">
                        <i class="fa fa-circle"></i>
                        <span>Functions vs Procedures</span>
                    </a>
                </li>
                
                <li>
                    <a href="/next/docs/fp-concepts/higher-kinded-types/">
                        <i class="fa fa-circle"></i>
                        <span>Higher Kinded Types</span>
                    </a>
                </li>
                
                <li>
                    <a href="/next/docs/fp-concepts/type-classes/">
                        <i class="fa fa-circle"></i>
                        <span>Type classes</span>
                    </a>
                </li>
                
                <li>
                    <a href="/next/docs/fp-concepts/data-types/">
                        <i class="fa fa-circle"></i>
                        <span>Data types</span>
                    </a>
                </li>
                
            </ul>
            
        </li>
        
        <li class="sidebar-nav-item">
            <a href="#">
                <span>Patterns</span>
                
                <i class="fa fa-angle-right"></i>
                
            </a>
            
            <ul>
                
                <li>
                    <a href="/next/docs/patterns/error-handling/">
                        <i class="fa fa-circle"></i>
                        <span>Error handling</span>
                    </a>
                </li>
                
                <li>
                    <a href="/next/docs/patterns/monad-comprehensions/">
                        <i class="fa fa-circle"></i>
                        <span>Monad comprehensions</span>
                    </a>
                </li>
                
                <li>
                    <a href="/next/docs/patterns/dependency-injection/">
                        <i class="fa fa-circle"></i>
                        <span>Dependency injection</span>
                    </a>
                </li>
                
                <li>
                    <a href="/next/docs/patterns/polymorphic-programs/">
                        <i class="fa fa-circle"></i>
                        <span>Polymorphic programs</span>
                    </a>
                </li>
                
            </ul>
            
        </li>
        
        <li class="sidebar-nav-item">
            <a href="#">
                <span>Optics</span>
                
                <i class="fa fa-angle-right"></i>
                
            </a>
            
            <ul>
                
                <li>
                    <a href="/next/docs/optics/overview/">
                        <i class="fa fa-circle"></i>
                        <span>Overview</span>
                    </a>
                </li>
                
                <li>
                    <a href="/next/docs/optics/writing-your-own-optics/">
                        <i class="fa fa-circle"></i>
                        <span>Writing your own optics</span>
                    </a>
                </li>
                
                <li>
                    <a href="/next/docs/optics/automatic-derivation/">
                        <i class="fa fa-circle"></i>
                        <span>Automatic derivation</span>
                    </a>
                </li>
                
                <li>
                    <a href="/next/docs/optics/composition/">
                        <i class="fa fa-circle"></i>
                        <span>Composition</span>
                    </a>
                </li>
                
            </ul>
            
        </li>
        
        <li class="sidebar-nav-item">
            <a href="#">
                <span>Effects</span>
                
                <i class="fa fa-angle-right"></i>
                
            </a>
            
            <ul>
                
                <li>
                    <a href="/next/docs/effects/overview/">
                        <i class="fa fa-circle"></i>
                        <span>Overview</span>
                    </a>
                </li>
                
                <li>
                    <a href="/next/docs/effects/suspending-side-effects/">
                        <i class="fa fa-circle"></i>
                        <span>Suspending side effects</span>
                    </a>
                </li>
                
                <li>
                    <a href="/next/docs/effects/manipulating-side-effects/">
                        <i class="fa fa-circle"></i>
                        <span>Manipulating side effects</span>
                    </a>
                </li>
                
                <li>
                    <a href="/next/docs/effects/handling-errors/">
                        <i class="fa fa-circle"></i>
                        <span>Handling errors</span>
                    </a>
                </li>
                
                <li>
                    <a href="/next/docs/effects/concurrency/">
                        <i class="fa fa-circle"></i>
                        <span>Concurrency</span>
                    </a>
                </li>
                
                <li>
                    <a href="/next/docs/effects/running-side-effects/">
                        <i class="fa fa-circle"></i>
                        <span>Running side effects</span>
                    </a>
                </li>
                
                <li>
                    <a href="/next/docs/effects/retrying-and-repeating-effects/">
                        <i class="fa fa-circle"></i>
                        <span>Retrying and repeating effects</span>
                    </a>
                </li>
                
                <li>
                    <a href="/next/docs/effects/handling-resources/">
                        <i class="fa fa-circle"></i>
                        <span>Handling resources</span>
                    </a>
                </li>
                
                <li>
                    <a href="/next/docs/effects/foundation-extensions/">
                        <i class="fa fa-circle"></i>
                        <span>Foundation extensions</span>
                    </a>
                </li>
                
            </ul>
            
        </li>
        
        <li class="sidebar-nav-item">
            <a href="#">
                <span>Integrations</span>
                
                <i class="fa fa-angle-right"></i>
                
            </a>
            
            <ul>
                
                <li>
                    <a href="/next/docs/integrations/rxswift-streams/">
                        <i class="fa fa-circle"></i>
                        <span>RxSwift streams</span>
                    </a>
                </li>
                
            </ul>
            
        </li>
        
        <li class="sidebar-nav-item">
            <a href="#">
                <span>Legal</span>
                
                <i class="fa fa-angle-right"></i>
                
            </a>
            
            <ul>
                
                <li>
                    <a href="/next/docs/legal/credits/">
                        <i class="fa fa-circle"></i>
                        <span>Credits</span>
                    </a>
                </li>
                
                <li>
                    <a href="/next/docs/legal/license/">
                        <i class="fa fa-circle"></i>
                        <span>License</span>
                    </a>
                </li>
                
            </ul>
            
        </li>
        
    </ul>
</div>

    <div id="doc-wrapper">
    <div class="doc-header">
        <button type="button" id="main-toggle" class="sidebar-toggle">
            <i class="fa fa-lg fa-bars menu-icon"></i>
        </button>
    </div>
    <div class="doc-content">
        <h1 id="error-handling">Error handling</h1>

<p class="beginner">beginner</p>

<p>Error handling is a common concern in software development. In this section, we are going to review multiple ways of doing this task by using a running example.</p>

<p>Consider we are developing an application where the user enters some personal information. We would like to validate the inputs before creating a form, and report any errors found. The validation rules provided by our business logic are:</p>

<ul>
  <li>First and last name must not be empty.</li>
  <li>Age must be over 18.</li>
  <li>Document ID must be 8 digits followed by a letter.</li>
  <li>Phone number must have 9 digits.</li>
  <li>Email must contain an @ symbol.</li>
</ul>

<h2 id="error-modeling">Error modeling</h2>

<p>Errors in Swift are usually modeled using the <code class="highlighter-rouge">Error</code> protocol. By conforming to it, we mark our type as an error, and it allows us to throw it from a throwing function or as a failure type in <code class="highlighter-rouge">Result</code>, as we will see later. Therefore, in our example, we can model our validation errors as:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">enum</span> <span class="kt">ValidationError</span><span class="p">:</span> <span class="kt">Error</span> <span class="p">{</span>
    <span class="k">case</span> <span class="nf">emptyFirstName</span><span class="p">(</span><span class="kt">String</span><span class="p">)</span>
    <span class="k">case</span> <span class="nf">emptyLastName</span><span class="p">(</span><span class="kt">String</span><span class="p">)</span>
    <span class="k">case</span> <span class="nf">userTooYoung</span><span class="p">(</span><span class="kt">Date</span><span class="p">)</span>
    <span class="k">case</span> <span class="nf">invalidDocumentId</span><span class="p">(</span><span class="kt">String</span><span class="p">)</span>
    <span class="k">case</span> <span class="nf">invalidPhoneNumber</span><span class="p">(</span><span class="kt">String</span><span class="p">)</span>
    <span class="k">case</span> <span class="nf">invalidEmail</span><span class="p">(</span><span class="kt">String</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p>That is, we are grouping all our errors regarding validation under a common type, <code class="highlighter-rouge">ValidationError</code>, that has a case for each class of error that our business rules distinguish. Also, we are attaching values to the errors to be able to provide more information about what went wrong.</p>

<h2 id="success-modeling">Success modeling</h2>

<p>In case everything went well, we would like to create a form with the validated data. To model this, we can use a struct:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">struct</span> <span class="kt">Form</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">firstName</span><span class="p">:</span> <span class="kt">String</span>
    <span class="k">let</span> <span class="nv">lastName</span><span class="p">:</span> <span class="kt">String</span>
    <span class="k">let</span> <span class="nv">birthday</span><span class="p">:</span> <span class="kt">Date</span>
    <span class="k">let</span> <span class="nv">documentId</span><span class="p">:</span> <span class="kt">String</span>
    <span class="k">let</span> <span class="nv">phoneNumber</span><span class="p">:</span> <span class="kt">String</span>
    <span class="k">let</span> <span class="nv">email</span><span class="p">:</span> <span class="kt">String</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Once we have models for success and error, let us explore several possibilities to write the validation logic for the example above.</p>

<h2 id="using-option--optional">Using Option / Optional</h2>

<p>A possible solution to indicate an error happened during the validation of one of the fields is to model it as an absent value. Swift introduces the <code class="highlighter-rouge">Optional&lt;Wrapped&gt;</code> type, usually sugared as <code class="highlighter-rouge">Wrapped?</code>, to model two cases: we either have a value of type <code class="highlighter-rouge">Wrapped</code>, or we don’t have a value at all, represented as <code class="highlighter-rouge">nil</code>.</p>

<p>Using <code class="highlighter-rouge">Optional&lt;Wrapped&gt;</code>, we could write one of the validation functions as:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">func</span> <span class="nf">validateOptional</span><span class="p">(</span><span class="nv">email</span><span class="p">:</span> <span class="kt">String</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">String</span><span class="p">?</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">email</span><span class="o">.</span><span class="nf">contains</span><span class="p">(</span><span class="s">"@"</span><span class="p">)</span> <span class="p">?</span>
        <span class="nv">email</span> <span class="p">:</span>
        <span class="kc">nil</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Bow provides the <code class="highlighter-rouge">Option&lt;A&gt;</code> type, which has the same semantics of <code class="highlighter-rouge">Optional&lt;A&gt;</code>, but simulates being a Higher-Kinded Type. The same function above could be written using <code class="highlighter-rouge">Option&lt;A&gt;</code>:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">func</span> <span class="nf">validateOption</span><span class="p">(</span><span class="nv">email</span><span class="p">:</span> <span class="kt">String</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Option</span><span class="o">&lt;</span><span class="kt">String</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">email</span><span class="o">.</span><span class="nf">contains</span><span class="p">(</span><span class="s">"@"</span><span class="p">)</span> <span class="p">?</span>
        <span class="o">.</span><span class="nf">some</span><span class="p">(</span><span class="n">email</span><span class="p">)</span> <span class="p">:</span>
        <span class="o">.</span><span class="nf">none</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">Option</code> and <code class="highlighter-rouge">Optional</code> are isomorphic; that is, the can be converted from/to each other without losing any information.</p>

<p>Modeling validation using this approach lets us distinguish between cases where everything went well and where there was an error. However, we are unable to know the reasons why the validation was wrong.</p>

<h2 id="throwing-errors">Throwing errors</h2>

<p>Another alternative is to use the throwing mechanisms provided in the language. Values conforming to <code class="highlighter-rouge">Error</code> can be thrown from a function as long as the function is marked with the <code class="highlighter-rouge">throws</code> keyword:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">func</span> <span class="nf">validateThrow</span><span class="p">(</span><span class="nv">email</span><span class="p">:</span> <span class="kt">String</span><span class="p">)</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">String</span> <span class="p">{</span>
    <span class="k">guard</span> <span class="n">email</span><span class="o">.</span><span class="nf">contains</span><span class="p">(</span><span class="s">"@"</span><span class="p">)</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">throw</span> <span class="kt">ValidationError</span><span class="o">.</span><span class="nf">invalidEmail</span><span class="p">(</span><span class="n">email</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">email</span>
<span class="p">}</span>
</code></pre></div></div>

<p>This approach let us catch the error thrown by this function and know the reason why it failed. However, there is still a problem. If we only look at the signature of the function, we do not have information about which type of errors this function is throwing; we would need to check the documentation or even the implementation of the function in order to know about it, and if it changes, we will not get a compiler error in the calling sites to remind us that we need to deal with a different type of error.</p>

<p>Moreover, throwing errors this way breaks referential transparency. We cannot reason about the output of the function in terms of its inputs, as there are two possible exits from the function: through the successful return or through the failed throw.</p>

<h2 id="try">Try</h2>

<p>In an attempt to overcome the referential transparency problem, Bow provides the <code class="highlighter-rouge">Try&lt;A&gt;</code> type, which models two possibilities: <code class="highlighter-rouge">Try.success</code> for successful value of type <code class="highlighter-rouge">A</code>, and <code class="highlighter-rouge">Try.failure</code> for a value conforming to <code class="highlighter-rouge">Error</code>. Thus, the throwing function above could be rewritten as:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">func</span> <span class="nf">validateTry</span><span class="p">(</span><span class="nv">email</span><span class="p">:</span> <span class="kt">String</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Try</span><span class="o">&lt;</span><span class="kt">String</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">guard</span> <span class="n">email</span><span class="o">.</span><span class="nf">contains</span><span class="p">(</span><span class="s">"@"</span><span class="p">)</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">return</span> <span class="kt">Try</span><span class="o">.</span><span class="nf">failure</span><span class="p">(</span><span class="kt">ValidationError</span><span class="o">.</span><span class="nf">invalidEmail</span><span class="p">(</span><span class="n">email</span><span class="p">))</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="kt">Try</span><span class="o">.</span><span class="nf">success</span><span class="p">(</span><span class="n">email</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">Try</code> also includes a constructor that is able to wrap a throwing function and convert it to a <code class="highlighter-rouge">Try</code> value:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">tryFromThrow</span> <span class="o">=</span> <span class="kt">Try</span><span class="o">.</span><span class="n">invoke</span> <span class="p">{</span> <span class="k">try</span> <span class="nf">validateThrow</span><span class="p">(</span><span class="nv">email</span><span class="p">:</span> <span class="s">"wrong_email.com"</span><span class="p">)</span> <span class="p">}</span>
</code></pre></div></div>

<p>Although <code class="highlighter-rouge">Try</code> solves the issue about breaking referential transparency, we still don’t have proper typing of the error that is happening. <code class="highlighter-rouge">Try</code> swallows it and represents it as the generic <code class="highlighter-rouge">Error</code> protocol. To achieve this, we need to use a type that lets us be explicit on the type error that we are using.</p>

<h2 id="result">Result</h2>

<p>Since Swift 5 we have a type that has the semantics we are looking for. Such type is <code class="highlighter-rouge">Result&lt;Success, Failure&gt;</code> that lets us represent either a successful value of type <code class="highlighter-rouge">Success</code> or a failure of type <code class="highlighter-rouge">Failure</code>. The type <code class="highlighter-rouge">Failure</code> must conform to <code class="highlighter-rouge">Error</code>.</p>

<p>Result has a constructor that lets us catch errors from a throwing function, similar to what we achieved with <code class="highlighter-rouge">Try</code>:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">catched</span><span class="p">:</span> <span class="kt">Result</span><span class="o">&lt;</span><span class="kt">String</span><span class="p">,</span> <span class="kt">Error</span><span class="o">&gt;</span> <span class="o">=</span> <span class="kt">Result</span><span class="p">(</span><span class="nv">catching</span><span class="p">:</span> <span class="p">{</span> <span class="k">try</span> <span class="nf">validateThrow</span><span class="p">(</span><span class="nv">email</span><span class="p">:</span> <span class="s">"wrong_email.com"</span><span class="p">)</span> <span class="p">})</span>
</code></pre></div></div>

<p>However, as we can guess, it does not have enough information about the error type that the function is throwing. Thus, we would need to rewrite our validation functions making the failure type explicit:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="kt">ValidationRules</span> <span class="p">{</span>
    <span class="kd">static</span> <span class="kd">func</span> <span class="nf">validate</span><span class="p">(</span><span class="nv">email</span><span class="p">:</span> <span class="kt">String</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Result</span><span class="o">&lt;</span><span class="kt">String</span><span class="p">,</span> <span class="kt">ValidationError</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">guard</span> <span class="n">email</span><span class="o">.</span><span class="nf">contains</span><span class="p">(</span><span class="s">"@"</span><span class="p">)</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">return</span> <span class="o">.</span><span class="nf">failure</span><span class="p">(</span><span class="o">.</span><span class="nf">invalidEmail</span><span class="p">(</span><span class="n">email</span><span class="p">))</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="o">.</span><span class="nf">success</span><span class="p">(</span><span class="n">email</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>This way, we still maintain referential transparency (our validation function is pure) and we have a concrete type describing the possible errors that may happen. If our failure type changes, we will get compiler errors everywhere we are calling this function and we will not miss them.</p>

<p>Up to this point, we are able to validate each individual field:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">firstNameResult</span> <span class="o">=</span> <span class="kt">ValidationRules</span><span class="o">.</span><span class="nf">validate</span><span class="p">(</span><span class="nv">firstName</span><span class="p">:</span> <span class="s">"Tomás"</span><span class="p">)</span>
<span class="k">let</span> <span class="nv">lastNameResult</span> <span class="o">=</span> <span class="kt">ValidationRules</span><span class="o">.</span><span class="nf">validate</span><span class="p">(</span><span class="nv">lastName</span><span class="p">:</span> <span class="s">"Ruiz-López"</span><span class="p">)</span>
<span class="k">let</span> <span class="nv">birtdayResult</span> <span class="o">=</span> <span class="kt">ValidationRules</span><span class="o">.</span><span class="nf">validate</span><span class="p">(</span><span class="nv">birthday</span><span class="p">:</span> <span class="kt">Date</span><span class="p">(</span><span class="nv">timeIntervalSince1970</span><span class="p">:</span> <span class="mi">1234</span><span class="p">),</span> <span class="nv">referenceDate</span><span class="p">:</span> <span class="kt">Date</span><span class="p">())</span>
<span class="k">let</span> <span class="nv">documentIdResult</span> <span class="o">=</span> <span class="kt">ValidationRules</span><span class="o">.</span><span class="nf">validate</span><span class="p">(</span><span class="nv">documentId</span><span class="p">:</span> <span class="s">"00000000A"</span><span class="p">)</span>
<span class="k">let</span> <span class="nv">phoneResult</span> <span class="o">=</span> <span class="kt">ValidationRules</span><span class="o">.</span><span class="nf">validate</span><span class="p">(</span><span class="nv">phoneNumber</span><span class="p">:</span> <span class="s">"000000000"</span><span class="p">)</span>
<span class="k">let</span> <span class="nv">emailResult</span> <span class="o">=</span> <span class="kt">ValidationRules</span><span class="o">.</span><span class="nf">validate</span><span class="p">(</span><span class="nv">email</span><span class="p">:</span> <span class="s">"myuser@email.com"</span><span class="p">)</span>
</code></pre></div></div>

<p>We need to combine them to make a <code class="highlighter-rouge">Form</code>, but its constructor does not take <code class="highlighter-rouge">Result</code> values. How can we proceed then?</p>

<p>When we need to inspect a <code class="highlighter-rouge">Result</code> value, we can do pattern matching over its two sides or, if we are just interested in transforming either side, we can use its <code class="highlighter-rouge">map</code> or <code class="highlighter-rouge">mapError</code> methods. What if we have several <code class="highlighter-rouge">Result</code> values? We can also pattern match over a tuple, but then we would need to deal with all possible combinations (or at least a number of them). It would be nice to have an API method similar to <code class="highlighter-rouge">map</code> but working with multiple values; however, the API in <code class="highlighter-rouge">Result</code> does not have it.</p>

<p>Besides this limitation, we would need to think about how to deal with multiple errors. There are two alternatives:</p>

<ol>
  <li>Fail-fast: return the first result that has a failure.</li>
  <li>Error-accumulation: return all results that have failures.</li>
</ol>

<p>Bow provides two types that are similar to <code class="highlighter-rouge">Result</code>, have a more expressive API and implement these strategies.</p>

<h2 id="either">Either</h2>

<p><code class="highlighter-rouge">Either&lt;A, B&gt;</code> represents the sum type of types <code class="highlighter-rouge">A</code> and <code class="highlighter-rouge">B</code>. It has two constructors: <code class="highlighter-rouge">Either.left</code> and <code class="highlighter-rouge">Either.right</code>. Unlike <code class="highlighter-rouge">Result</code>, it does not impose any restriction on the types you can use; there is no need to conform to <code class="highlighter-rouge">Error</code>. You can view <code class="highlighter-rouge">Either.left</code> as equivalent to <code class="highlighter-rouge">Result.failure</code> and <code class="highlighter-rouge">Either.right</code> as equivalent to <code class="highlighter-rouge">Result.success</code>.</p>

<p>When the left type conforms to <code class="highlighter-rouge">Error</code>, <code class="highlighter-rouge">Either</code> can be converted to <code class="highlighter-rouge">Result</code> and back:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">result</span><span class="p">:</span> <span class="kt">Result</span><span class="o">&lt;</span><span class="kt">String</span><span class="p">,</span> <span class="kt">ValidationError</span><span class="o">&gt;</span> <span class="o">=</span> <span class="kt">Either</span><span class="o">.</span><span class="nf">right</span><span class="p">(</span><span class="s">"Tomás"</span><span class="p">)</span><span class="o">.</span><span class="nf">toResult</span><span class="p">()</span>
<span class="k">let</span> <span class="nv">either</span><span class="p">:</span> <span class="kt">Either</span><span class="o">&lt;</span><span class="kt">ValidationError</span><span class="p">,</span> <span class="kt">String</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="nf">toEither</span><span class="p">()</span>
</code></pre></div></div>

<p>Notice that the type arguments in <code class="highlighter-rouge">Either</code> are reversed respect to the ones in <code class="highlighter-rouge">Result</code>. This is due to how Higher-Kinded Types are simulated in Bow: types are partially applied from left to right, so the successful part must always be at the right-most position of the type.</p>

<p>We can write the validation functions using <code class="highlighter-rouge">Either</code>:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="kt">FailFast</span> <span class="p">{</span>
    <span class="kd">static</span> <span class="kd">func</span> <span class="nf">validate</span><span class="p">(</span><span class="nv">email</span><span class="p">:</span> <span class="kt">String</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Either</span><span class="o">&lt;</span><span class="kt">ValidationError</span><span class="p">,</span> <span class="kt">String</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">guard</span> <span class="n">email</span><span class="o">.</span><span class="nf">contains</span><span class="p">(</span><span class="s">"@"</span><span class="p">)</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">return</span> <span class="o">.</span><span class="nf">left</span><span class="p">(</span><span class="o">.</span><span class="nf">invalidEmail</span><span class="p">(</span><span class="n">email</span><span class="p">))</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="o">.</span><span class="nf">right</span><span class="p">(</span><span class="n">email</span><span class="p">)</span>
    <span class="p">}</span>
    
    <span class="c1">// Implementation of the rest of validation functions</span>
<span class="p">}</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">Either</code> has a method that lets us map over multiple values. We can pass it multiple values and a function, and it will invoke it if every one of them is successful. In case one or more values are unsuccessful, the first failure is returned. In our case, the combination function is the initializer of the <code class="highlighter-rouge">Form</code> that we need to creat. The implementation of the combination function using a fail-fast strategy is:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">extension</span> <span class="kt">FailFast</span> <span class="p">{</span>
    <span class="kd">static</span> <span class="kd">func</span> <span class="nf">validate</span><span class="p">(</span><span class="nv">firstName</span><span class="p">:</span> <span class="kt">String</span><span class="p">,</span>
                         <span class="nv">lastName</span><span class="p">:</span> <span class="kt">String</span><span class="p">,</span>
                         <span class="nv">birthday</span><span class="p">:</span> <span class="kt">Date</span><span class="p">,</span>
                         <span class="nv">documentId</span><span class="p">:</span> <span class="kt">String</span><span class="p">,</span>
                         <span class="nv">phoneNumber</span><span class="p">:</span> <span class="kt">String</span><span class="p">,</span>
                         <span class="nv">email</span><span class="p">:</span> <span class="kt">String</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Either</span><span class="o">&lt;</span><span class="kt">ValidationError</span><span class="p">,</span> <span class="kt">Form</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">return</span> <span class="kt">Either</span><span class="o">&lt;</span><span class="kt">ValidationError</span><span class="p">,</span> <span class="kt">Form</span><span class="o">&gt;.</span><span class="nf">map</span><span class="p">(</span>
            <span class="nf">validate</span><span class="p">(</span><span class="nv">firstName</span><span class="p">:</span> <span class="n">firstName</span><span class="p">),</span>
            <span class="nf">validate</span><span class="p">(</span><span class="nv">lastName</span><span class="p">:</span> <span class="n">lastName</span><span class="p">),</span>
            <span class="nf">validate</span><span class="p">(</span><span class="nv">birthday</span><span class="p">:</span> <span class="n">birthday</span><span class="p">,</span> <span class="nv">referenceDate</span><span class="p">:</span> <span class="kt">Date</span><span class="p">()),</span>
            <span class="nf">validate</span><span class="p">(</span><span class="nv">documentId</span><span class="p">:</span> <span class="n">documentId</span><span class="p">),</span>
            <span class="nf">validate</span><span class="p">(</span><span class="nv">phoneNumber</span><span class="p">:</span> <span class="n">phoneNumber</span><span class="p">),</span>
            <span class="nf">validate</span><span class="p">(</span><span class="nv">email</span><span class="p">:</span> <span class="n">email</span><span class="p">),</span>
            <span class="kt">Form</span><span class="o">.</span><span class="kd">init</span><span class="p">)</span><span class="o">^</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Thus, invoking this with correct parameters will return an <code class="highlighter-rouge">Either.right</code> containing a <code class="highlighter-rouge">Form</code>, whereas invoking it with one or more incorrect parameters will return an <code class="highlighter-rouge">Either.left</code> with the first error that it finds.</p>

<h2 id="validated">Validated</h2>

<p>Similarly, <code class="highlighter-rouge">Validated&lt;A, B&gt;</code> represents the case of having a valid value of type <code class="highlighter-rouge">B</code>, or an invalid value of type <code class="highlighter-rouge">A</code>. It has two constructors: <code class="highlighter-rouge">Validated.valid</code>, similar to <code class="highlighter-rouge">Result.success</code>, and <code class="highlighter-rouge">Validated.invalid</code>, similar to <code class="highlighter-rouge">Result.failure</code>, with the difference that <code class="highlighter-rouge">Validated</code> does not impose the invalid type to conform to <code class="highlighter-rouge">Error</code>.</p>

<p><code class="highlighter-rouge">Validated</code> can be transformed to <code class="highlighter-rouge">Result</code> and back, as long as the invalid type conforms to <code class="highlighter-rouge">Error</code>:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">resultFromValidated</span><span class="p">:</span> <span class="kt">Result</span><span class="o">&lt;</span><span class="kt">String</span><span class="p">,</span> <span class="kt">ValidationError</span><span class="o">&gt;</span> <span class="o">=</span> <span class="kt">Validated</span><span class="o">.</span><span class="nf">valid</span><span class="p">(</span><span class="s">"Tomás"</span><span class="p">)</span><span class="o">.</span><span class="nf">toResult</span><span class="p">()</span>
<span class="k">let</span> <span class="nv">validatedFromResult</span><span class="p">:</span> <span class="kt">Validated</span><span class="o">&lt;</span><span class="kt">ValidationError</span><span class="p">,</span> <span class="kt">String</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">resultFromValidated</span><span class="o">.</span><span class="nf">toValidated</span><span class="p">()</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">Validated</code> has an API similar to <code class="highlighter-rouge">Either</code> to combine different values through the <code class="highlighter-rouge">map</code> function. The main difference is that it does error accumulation. To do so, the invalid type needs to be able to accumulate errors; that is, it needs to conform to <code class="highlighter-rouge">Semigroup</code>.</p>

<p>Since this pattern is very usual in Functional Programming, there is a type to do this kind of accumulation: <code class="highlighter-rouge">NonEmptyArray</code>. <code class="highlighter-rouge">NonEmptyArray</code>, or <code class="highlighter-rouge">NEA</code> for short, represents an array with at least one element. The reason to use this type instead of a regular array is to avoid an inconsistent state where we are in a <code class="highlighter-rouge">Validated.invalid</code> value, but have an empry array with no errors.</p>

<p>Therefore, we can model our functions to return <code class="highlighter-rouge">Validated&lt;NonEmptyArray&lt;ValidationError&gt;, String&gt;</code>. As this name is quite long and the pattern is usual, Bow includes a type alias for this, which lets us write <code class="highlighter-rouge">ValidatedNEA&lt;ValidationError, String&gt;</code>.</p>

<p>Bow also includes functions to transform to <code class="highlighter-rouge">ValidatedNEA</code>:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">validatedNEAFromResult</span><span class="p">:</span> <span class="kt">ValidatedNEA</span><span class="o">&lt;</span><span class="kt">ValidationError</span><span class="p">,</span> <span class="kt">String</span><span class="o">&gt;</span> <span class="o">=</span> <span class="kt">Result</span><span class="o">.</span><span class="nf">success</span><span class="p">(</span><span class="s">"Tomás"</span><span class="p">)</span><span class="o">.</span><span class="nf">toValidatedNEA</span><span class="p">()</span>
<span class="k">let</span> <span class="nv">validatedNEAFromValidated</span><span class="p">:</span> <span class="kt">ValidatedNEA</span><span class="o">&lt;</span><span class="kt">ValidationError</span><span class="p">,</span> <span class="kt">String</span><span class="o">&gt;</span> <span class="o">=</span> <span class="kt">Validated</span><span class="o">.</span><span class="nf">valid</span><span class="p">(</span><span class="s">"Tomás"</span><span class="p">)</span><span class="o">.</span><span class="nf">toValidatedNEA</span><span class="p">()</span>
</code></pre></div></div>

<p>Thus, we can use <code class="highlighter-rouge">ValidatedNEA</code> to write our validation functions:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="kt">ErrorAccumulation</span> <span class="p">{</span>
    <span class="kd">static</span> <span class="kd">func</span> <span class="nf">validate</span><span class="p">(</span><span class="nv">email</span><span class="p">:</span> <span class="kt">String</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">ValidatedNEA</span><span class="o">&lt;</span><span class="kt">ValidationError</span><span class="p">,</span> <span class="kt">String</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">guard</span> <span class="n">email</span><span class="o">.</span><span class="nf">contains</span><span class="p">(</span><span class="s">"@"</span><span class="p">)</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">return</span> <span class="o">.</span><span class="nf">invalid</span><span class="p">(</span><span class="o">.</span><span class="nf">of</span><span class="p">(</span><span class="o">.</span><span class="nf">invalidEmail</span><span class="p">(</span><span class="n">email</span><span class="p">)))</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="o">.</span><span class="nf">valid</span><span class="p">(</span><span class="n">email</span><span class="p">)</span>
    <span class="p">}</span>
    
    <span class="c1">// Implementation of the rest of validation functions</span>
<span class="p">}</span>
</code></pre></div></div>

<p>And finally, making use of <code class="highlighter-rouge">Validated.map</code>, we can write our validation function that combines all successful results into a Form or accumulates all errors found:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">extension</span> <span class="kt">ErrorAccumulation</span> <span class="p">{</span>
    <span class="kd">static</span> <span class="kd">func</span> <span class="nf">validate</span><span class="p">(</span><span class="nv">firstName</span><span class="p">:</span> <span class="kt">String</span><span class="p">,</span>
                         <span class="nv">lastName</span><span class="p">:</span> <span class="kt">String</span><span class="p">,</span>
                         <span class="nv">birthday</span><span class="p">:</span> <span class="kt">Date</span><span class="p">,</span>
                         <span class="nv">documentId</span><span class="p">:</span> <span class="kt">String</span><span class="p">,</span>
                         <span class="nv">phoneNumber</span><span class="p">:</span> <span class="kt">String</span><span class="p">,</span>
                         <span class="nv">email</span><span class="p">:</span> <span class="kt">String</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">ValidatedNEA</span><span class="o">&lt;</span><span class="kt">ValidationError</span><span class="p">,</span> <span class="kt">Form</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">return</span> <span class="kt">ValidatedNEA</span><span class="o">&lt;</span><span class="kt">ValidationError</span><span class="p">,</span> <span class="kt">Form</span><span class="o">&gt;.</span><span class="nf">map</span><span class="p">(</span>
            <span class="nf">validate</span><span class="p">(</span><span class="nv">firstName</span><span class="p">:</span> <span class="n">firstName</span><span class="p">),</span>
            <span class="nf">validate</span><span class="p">(</span><span class="nv">lastName</span><span class="p">:</span> <span class="n">lastName</span><span class="p">),</span>
            <span class="nf">validate</span><span class="p">(</span><span class="nv">birthday</span><span class="p">:</span> <span class="n">birthday</span><span class="p">,</span> <span class="nv">referenceDate</span><span class="p">:</span> <span class="kt">Date</span><span class="p">()),</span>
            <span class="nf">validate</span><span class="p">(</span><span class="nv">documentId</span><span class="p">:</span> <span class="n">documentId</span><span class="p">),</span>
            <span class="nf">validate</span><span class="p">(</span><span class="nv">phoneNumber</span><span class="p">:</span> <span class="n">phoneNumber</span><span class="p">),</span>
            <span class="nf">validate</span><span class="p">(</span><span class="nv">email</span><span class="p">:</span> <span class="n">email</span><span class="p">),</span>
            <span class="kt">Form</span><span class="o">.</span><span class="kd">init</span><span class="p">)</span><span class="o">^</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p class="intermediate">intermediate</p>

<h2 id="applicative">Applicative</h2>

<p>If we examine carefully both validation functions (fail-fast and error accumulation), we can observe a similar pattern. In fact, the only thing that changes is the type we are using to invoke the function. That suggests that we could write a single validation function that operates on a type parameter, constrained by a protocol (a type class) that abstracts the <code class="highlighter-rouge">map</code> operation.</p>

<p>Such type class is known as <code class="highlighter-rouge">Applicative</code> and it is particularly used to perform multiple independent effects and combine their results. That is, in fact, what we are doing here: we are evaluating 6 independent validations and combining their successful results. Both <code class="highlighter-rouge">Either</code> and <code class="highlighter-rouge">Validated</code> have instances for <code class="highlighter-rouge">Applicative</code>; that is, they conform to this protocol. But they are not the only types to do so; in fact, we could also write a validation function to combine validations returning <code class="highlighter-rouge">Option</code>:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="kt">OptionValidation</span> <span class="p">{</span>
    <span class="kd">static</span> <span class="kd">func</span> <span class="nf">validate</span><span class="p">(</span><span class="nv">email</span><span class="p">:</span> <span class="kt">String</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Option</span><span class="o">&lt;</span><span class="kt">String</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">guard</span> <span class="n">email</span><span class="o">.</span><span class="nf">contains</span><span class="p">(</span><span class="s">"@"</span><span class="p">)</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">return</span> <span class="o">.</span><span class="nf">none</span><span class="p">()</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="o">.</span><span class="nf">some</span><span class="p">(</span><span class="n">email</span><span class="p">)</span>
    <span class="p">}</span>
    
    <span class="c1">// Implementation of the rest of validation functions</span>
<span class="p">}</span>

<span class="kd">extension</span> <span class="kt">OptionValidation</span> <span class="p">{</span>
    <span class="kd">static</span> <span class="kd">func</span> <span class="nf">validate</span><span class="p">(</span><span class="nv">firstName</span><span class="p">:</span> <span class="kt">String</span><span class="p">,</span>
                         <span class="nv">lastName</span><span class="p">:</span> <span class="kt">String</span><span class="p">,</span>
                         <span class="nv">birthday</span><span class="p">:</span> <span class="kt">Date</span><span class="p">,</span>
                         <span class="nv">documentId</span><span class="p">:</span> <span class="kt">String</span><span class="p">,</span>
                         <span class="nv">phoneNumber</span><span class="p">:</span> <span class="kt">String</span><span class="p">,</span>
                         <span class="nv">email</span><span class="p">:</span> <span class="kt">String</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Option</span><span class="o">&lt;</span><span class="kt">Form</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">return</span> <span class="kt">Option</span><span class="o">&lt;</span><span class="kt">Form</span><span class="o">&gt;.</span><span class="nf">map</span><span class="p">(</span>
            <span class="nf">validate</span><span class="p">(</span><span class="nv">firstName</span><span class="p">:</span> <span class="n">firstName</span><span class="p">),</span>
            <span class="nf">validate</span><span class="p">(</span><span class="nv">lastName</span><span class="p">:</span> <span class="n">lastName</span><span class="p">),</span>
            <span class="nf">validate</span><span class="p">(</span><span class="nv">birthday</span><span class="p">:</span> <span class="n">birthday</span><span class="p">,</span> <span class="nv">referenceDate</span><span class="p">:</span> <span class="kt">Date</span><span class="p">()),</span>
            <span class="nf">validate</span><span class="p">(</span><span class="nv">documentId</span><span class="p">:</span> <span class="n">documentId</span><span class="p">),</span>
            <span class="nf">validate</span><span class="p">(</span><span class="nv">phoneNumber</span><span class="p">:</span> <span class="n">phoneNumber</span><span class="p">),</span>
            <span class="nf">validate</span><span class="p">(</span><span class="nv">email</span><span class="p">:</span> <span class="n">email</span><span class="p">),</span>
            <span class="kt">Form</span><span class="o">.</span><span class="kd">init</span><span class="p">)</span><span class="o">^</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>In this case, we would lose the information about the error type, as we discussed above, but we would still be able to have the combination of successful values.</p>

<p>What about <code class="highlighter-rouge">Result</code>? Would it be possible to do the same? We could definitely write <code class="highlighter-rouge">map</code> as an extension to <code class="highlighter-rouge">Result</code> to perform this type of operations. Since it already implements a <code class="highlighter-rouge">flatMap</code> operation, <code class="highlighter-rouge">Result</code> must have a fail-fast policy. The reason behind this is that <code class="highlighter-rouge">map</code> with multiple parameters can be derived from a <code class="highlighter-rouge">flatMap</code> implementation, but adding error accumulation leads to a lack of consistency of the results we can obtain. In other words, <code class="highlighter-rouge">Applicative</code> and <code class="highlighter-rouge">Monad</code> (where <code class="highlighter-rouge">flatMap</code> is defined<code class="highlighter-rouge">) have some rules that every implementation must adhere to, and implementations based on </code>flatMap` do not fulfill these rules if we start accumulating errors.</p>

<p>Besides this, <code class="highlighter-rouge">Applicative</code> is a protocol that operates on Higher-Kinded Types. At the moment, HKT are not supported natively, so only types which are build with the simulation that Bow provides can conform to this type of protocols. We could write a wrapper of <code class="highlighter-rouge">Result</code> to make it an HKT (named, for instance, <code class="highlighter-rouge">ResultK</code>), in a similar way our <code class="highlighter-rouge">Option</code> wraps Swift <code class="highlighter-rouge">Optional</code> type; however, <code class="highlighter-rouge">Either</code> generalizes what <code class="highlighter-rouge">ResultK</code> would do. In fact, it would be as easy as creating a type alias:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">typealias</span> <span class="kt">ResultK</span><span class="o">&lt;</span><span class="kt">B</span><span class="p">,</span> <span class="kt">A</span><span class="o">&gt;</span> <span class="o">=</span> <span class="kt">Either</span><span class="o">&lt;</span><span class="kt">A</span><span class="p">,</span> <span class="kt">B</span><span class="o">&gt;</span> <span class="k">where</span> <span class="kt">A</span><span class="p">:</span> <span class="kt">Error</span>

<span class="kd">extension</span> <span class="kt">ResultK</span> <span class="k">where</span> <span class="kt">A</span><span class="p">:</span> <span class="kt">Error</span> <span class="p">{</span>
    <span class="kd">static</span> <span class="kd">func</span> <span class="nf">success</span><span class="p">(</span><span class="n">_</span> <span class="nv">value</span><span class="p">:</span> <span class="kt">B</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">ResultK</span><span class="o">&lt;</span><span class="kt">B</span><span class="p">,</span> <span class="kt">A</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">return</span> <span class="o">.</span><span class="nf">right</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
    <span class="p">}</span>
    
    <span class="kd">static</span> <span class="kd">func</span> <span class="nf">failure</span><span class="p">(</span><span class="n">_</span> <span class="nv">error</span><span class="p">:</span> <span class="kt">A</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">ResultK</span><span class="o">&lt;</span><span class="kt">B</span><span class="p">,</span> <span class="kt">A</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">return</span> <span class="o">.</span><span class="nf">left</span><span class="p">(</span><span class="n">error</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>This way, we could have a <code class="highlighter-rouge">Result</code>-like type that has conformance to <code class="highlighter-rouge">Applicative</code> and many other type classes.</p>

<h2 id="applicativeerror">ApplicativeError</h2>

<p>If we look closely, <code class="highlighter-rouge">Applicative.map</code> is not the only pattern we can observe in our code above. In fact, all validation functions reduce to checking some conditions and then creating a wrapper over the success or error values depending on the type we are returning.</p>

<p>We can generalize that with the <code class="highlighter-rouge">ApplicativeError</code> type class. <code class="highlighter-rouge">ApplicativeError</code> augments <code class="highlighter-rouge">Applicative</code> with error handling capabilities. It provides functions to create those wrappers for the success and error values in a general way. The correspondence with <code class="highlighter-rouge">Either</code> and <code class="highlighter-rouge">Validated</code> is:</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">ApplicativeError</th>
      <th style="text-align: center">Either</th>
      <th style="text-align: center">Validated</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">pure</td>
      <td style="text-align: center">right</td>
      <td style="text-align: center">valid</td>
    </tr>
    <tr>
      <td style="text-align: center">raiseError</td>
      <td style="text-align: center">left</td>
      <td style="text-align: center">invalid</td>
    </tr>
  </tbody>
</table>

<p>Then, we can write the validation functions in an abstract manner, without knowing which type they will be evaluated to, and knowing the error type will be <code class="highlighter-rouge">NonEmptyArray&lt;ValidationError&gt;</code>:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="kt">GeneralValidationRules</span><span class="o">&lt;</span><span class="kt">F</span><span class="p">:</span> <span class="kt">ApplicativeError</span><span class="o">&gt;</span> <span class="k">where</span> <span class="kt">F</span><span class="o">.</span><span class="kt">E</span> <span class="o">==</span> <span class="kt">NEA</span><span class="o">&lt;</span><span class="kt">ValidationError</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="kd">static</span> <span class="kd">func</span> <span class="nf">validate</span><span class="p">(</span><span class="nv">email</span><span class="p">:</span> <span class="kt">String</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Kind</span><span class="o">&lt;</span><span class="kt">F</span><span class="p">,</span> <span class="kt">String</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">guard</span> <span class="n">email</span><span class="o">.</span><span class="nf">contains</span><span class="p">(</span><span class="s">"@"</span><span class="p">)</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">return</span> <span class="o">.</span><span class="nf">raiseError</span><span class="p">(</span><span class="o">.</span><span class="nf">of</span><span class="p">(</span><span class="o">.</span><span class="nf">invalidEmail</span><span class="p">(</span><span class="n">email</span><span class="p">)))</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="o">.</span><span class="nf">pure</span><span class="p">(</span><span class="n">email</span><span class="p">)</span>
    <span class="p">}</span>
    
    <span class="c1">// Implementation of the rest of validation functions</span>
<span class="p">}</span>

<span class="kd">extension</span> <span class="kt">GeneralValidationRules</span> <span class="p">{</span>
    <span class="kd">static</span> <span class="kd">func</span> <span class="nf">validate</span><span class="p">(</span><span class="nv">firstName</span><span class="p">:</span> <span class="kt">String</span><span class="p">,</span>
                         <span class="nv">lastName</span><span class="p">:</span> <span class="kt">String</span><span class="p">,</span>
                         <span class="nv">birthday</span><span class="p">:</span> <span class="kt">Date</span><span class="p">,</span>
                         <span class="nv">documentId</span><span class="p">:</span> <span class="kt">String</span><span class="p">,</span>
                         <span class="nv">phoneNumber</span><span class="p">:</span> <span class="kt">String</span><span class="p">,</span>
                         <span class="nv">email</span><span class="p">:</span> <span class="kt">String</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Kind</span><span class="o">&lt;</span><span class="kt">F</span><span class="p">,</span> <span class="kt">Form</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">return</span> <span class="kt">Kind</span><span class="o">&lt;</span><span class="kt">F</span><span class="p">,</span> <span class="kt">Form</span><span class="o">&gt;.</span><span class="nf">map</span><span class="p">(</span>
            <span class="nf">validate</span><span class="p">(</span><span class="nv">firstName</span><span class="p">:</span> <span class="n">firstName</span><span class="p">),</span>
            <span class="nf">validate</span><span class="p">(</span><span class="nv">lastName</span><span class="p">:</span> <span class="n">lastName</span><span class="p">),</span>
            <span class="nf">validate</span><span class="p">(</span><span class="nv">birthday</span><span class="p">:</span> <span class="n">birthday</span><span class="p">,</span> <span class="nv">referenceDate</span><span class="p">:</span> <span class="kt">Date</span><span class="p">()),</span>
            <span class="nf">validate</span><span class="p">(</span><span class="nv">documentId</span><span class="p">:</span> <span class="n">documentId</span><span class="p">),</span>
            <span class="nf">validate</span><span class="p">(</span><span class="nv">phoneNumber</span><span class="p">:</span> <span class="n">phoneNumber</span><span class="p">),</span>
            <span class="nf">validate</span><span class="p">(</span><span class="nv">email</span><span class="p">:</span> <span class="n">email</span><span class="p">),</span>
            <span class="kt">Form</span><span class="o">.</span><span class="kd">init</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>With this implementation, we just need to pass the type we want to interpret to as a type argument. Using <code class="highlighter-rouge">Either</code> we get fail-fast behavior:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">failfast</span> <span class="o">=</span> <span class="kt">GeneralValidationRules</span><span class="o">&lt;</span><span class="kt">EitherPartial</span><span class="o">&lt;</span><span class="kt">NEA</span><span class="o">&lt;</span><span class="kt">ValidationError</span><span class="o">&gt;&gt;&gt;</span>
    <span class="o">.</span><span class="nf">validate</span><span class="p">(</span><span class="nv">firstName</span><span class="p">:</span> <span class="s">" "</span><span class="p">,</span>
              <span class="nv">lastName</span><span class="p">:</span> <span class="s">"  "</span><span class="p">,</span>
              <span class="nv">birthday</span><span class="p">:</span> <span class="kt">Date</span><span class="p">(),</span>
              <span class="nv">documentId</span><span class="p">:</span> <span class="s">"---"</span><span class="p">,</span>
              <span class="nv">phoneNumber</span><span class="p">:</span> <span class="s">"?"</span><span class="p">,</span>
              <span class="nv">email</span><span class="p">:</span> <span class="s">"no_email"</span><span class="p">)</span><span class="o">^</span>
</code></pre></div></div>

<p>And with <code class="highlighter-rouge">Validated</code>, we get error accumulation:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">accumulation</span> <span class="o">=</span> <span class="kt">GeneralValidationRules</span><span class="o">&lt;</span><span class="kt">ValidatedPartial</span><span class="o">&lt;</span><span class="kt">NEA</span><span class="o">&lt;</span><span class="kt">ValidationError</span><span class="o">&gt;&gt;&gt;</span>
    <span class="o">.</span><span class="nf">validate</span><span class="p">(</span><span class="nv">firstName</span><span class="p">:</span> <span class="s">" "</span><span class="p">,</span>
              <span class="nv">lastName</span><span class="p">:</span> <span class="s">"  "</span><span class="p">,</span>
              <span class="nv">birthday</span><span class="p">:</span> <span class="kt">Date</span><span class="p">(),</span>
              <span class="nv">documentId</span><span class="p">:</span> <span class="s">"---"</span><span class="p">,</span>
              <span class="nv">phoneNumber</span><span class="p">:</span> <span class="s">"?"</span><span class="p">,</span>
              <span class="nv">email</span><span class="p">:</span> <span class="s">"no_email"</span><span class="p">)</span><span class="o">^</span>
</code></pre></div></div>

<p>Using this approach, we have a single implementation of the validation rules, but multiple strategies to evaluate them.</p>

    </div>
</div>

</div>
<!-- Custom scripts for this template -->
<script src="/next/js/docs.js"></script>
<!-- Gitter -->
<script>
  ((window.gitter = {}).chat = {}).options = {
    room: 'bowswift/bow'
  };
</script>
<script src="https://sidecar.gitter.im/dist/sidecar.v1.js" async defer></script>

</body>
</html>
